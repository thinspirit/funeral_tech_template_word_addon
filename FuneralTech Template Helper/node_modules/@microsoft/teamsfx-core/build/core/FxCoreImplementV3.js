"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.FxCoreV3Implement = void 0;
const tslib_1 = require("tslib");
const hooks_1 = require("@feathersjs/hooks");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const os = tslib_1.__importStar(require("os"));
const path = tslib_1.__importStar(require("path"));
const typedi_1 = require("typedi");
const url_1 = require("url");
const constants_1 = require("../common/constants");
const localizeUtils_1 = require("../common/localizeUtils");
const launchHelper_1 = require("../common/m365/launchHelper");
const projectSettingsHelper_1 = require("../common/projectSettingsHelper");
const versionMetadata_1 = require("../common/versionMetadata");
const constants_2 = require("../component/constants");
const coordinator_1 = require("../component/coordinator");
const buildAadManifest_1 = require("../component/driver/aad/utility/buildAadManifest");
require("../component/driver/index");
const appStudio_1 = require("../component/driver/teamsApp/appStudio");
const ManifestUtils_1 = require("../component/driver/teamsApp/utils/ManifestUtils");
const utils_1 = require("../component/driver/teamsApp/utils/utils");
const envMW_1 = require("../component/middleware/envMW");
const questionMW_1 = require("../component/middleware/questionMW");
const utils_2 = require("../component/utils");
const envUtil_1 = require("../component/utils/envUtil");
const pathUtils_1 = require("../component/utils/pathUtils");
const common_1 = require("../error/common");
const upgrade_1 = require("../error/upgrade");
const yml_1 = require("../error/yml");
const question_1 = require("../question");
const create_1 = require("../question/create");
const other_1 = require("../question/other");
const questionNames_1 = require("../question/questionNames");
const collaborator_1 = require("./collaborator");
const error_1 = require("./error");
const globalVars_1 = require("./globalVars");
const concurrentLocker_1 = require("./middleware/concurrentLocker");
const contextInjector_1 = require("./middleware/contextInjector");
const errorHandler_1 = require("./middleware/errorHandler");
const projectMigratorV3_1 = require("./middleware/projectMigratorV3");
const v3MigrationUtils_1 = require("./middleware/utils/v3MigrationUtils");
const telemetry_1 = require("./telemetry");
class FxCoreV3Implement {
    constructor(tools) {
        this.tools = tools;
    }
    async dispatch(exec, inputs) {
        const methodName = exec.name;
        if (!this[methodName]) {
            throw new Error("no implement");
        }
        const method = this[methodName];
        return await method.call(this, inputs);
    }
    async dispatchUserTask(exec, func, inputs) {
        const methodName = exec.name;
        if (!this[methodName]) {
            throw new Error("no implement");
        }
        const method = this[methodName];
        return await method.call(this, func, inputs);
    }
    async createProject(inputs) {
        const context = utils_2.createContextV3();
        if (inputs.teamsAppFromTdp) {
            // should never happen as we do same check on Developer Portal.
            if (utils_1.containsUnsupportedFeature(inputs.teamsAppFromTdp)) {
                return teamsfx_api_1.err(error_1.InvalidInputError("Teams app contains unsupported features"));
            }
            else {
                context.telemetryReporter.sendTelemetryEvent(telemetry_1.CoreTelemetryEvent.CreateFromTdpStart, {
                    [telemetry_1.CoreTelemetryProperty.TdpTeamsAppFeatures]: utils_1.getFeaturesFromAppDefinition(inputs.teamsAppFromTdp).join(","),
                    [telemetry_1.CoreTelemetryProperty.TdpTeamsAppId]: inputs.teamsAppFromTdp.teamsAppId,
                });
            }
        }
        const res = await coordinator_1.coordinator.create(context, inputs);
        if (res.isErr())
            return teamsfx_api_1.err(res.error);
        inputs.projectPath = context.projectPath;
        return teamsfx_api_1.ok(inputs.projectPath);
    }
    async provisionResources(inputs, ctx) {
        inputs.stage = teamsfx_api_1.Stage.provision;
        const context = utils_2.createDriverContext(inputs);
        try {
            const res = await coordinator_1.coordinator.provision(context, inputs);
            if (res.isOk()) {
                ctx.envVars = res.value;
                return teamsfx_api_1.ok(teamsfx_api_1.Void);
            }
            else {
                // for partial success scenario, output is set in inputs object
                ctx.envVars = inputs.envVars;
                return teamsfx_api_1.err(res.error);
            }
        }
        finally {
            //reset subscription
            try {
                await globalVars_1.TOOLS.tokenProvider.azureAccountProvider.setSubscription("");
            }
            catch (e) { }
        }
    }
    async deployArtifacts(inputs, ctx) {
        inputs.stage = teamsfx_api_1.Stage.deploy;
        const context = utils_2.createDriverContext(inputs);
        const res = await coordinator_1.coordinator.deploy(context, inputs);
        if (res.isOk()) {
            ctx.envVars = res.value;
            return teamsfx_api_1.ok(teamsfx_api_1.Void);
        }
        else {
            // for partial success scenario, output is set in inputs object
            ctx.envVars = inputs.envVars;
            return teamsfx_api_1.err(res.error);
        }
    }
    async deployAadManifest(inputs) {
        inputs.stage = teamsfx_api_1.Stage.deployAad;
        const updateAadClient = typedi_1.Container.get("aadApp/update");
        // In V3, the aad.template.json exist at .fx folder, and output to root build folder.
        const manifestTemplatePath = inputs[questionNames_1.QuestionNames.AadAppManifestFilePath];
        if (!(await fs_extra_1.default.pathExists(manifestTemplatePath))) {
            return teamsfx_api_1.err(new common_1.FileNotFoundError("deployAadManifest", manifestTemplatePath));
        }
        let manifestOutputPath = manifestTemplatePath;
        if (inputs.env && (await other_1.isAadMainifestContainsPlaceholder(inputs))) {
            await fs_extra_1.default.ensureDir(path.join(inputs.projectPath, "build"));
            manifestOutputPath = path.join(inputs.projectPath, "build", `aad.manifest.${inputs.env}.json`);
        }
        const inputArgs = {
            manifestPath: manifestTemplatePath,
            outputFilePath: manifestOutputPath,
        };
        const Context = utils_2.createDriverContext(inputs);
        const res = await updateAadClient.run(inputArgs, Context);
        if (res.isErr()) {
            return teamsfx_api_1.err(res.error);
        }
        if (Context.platform === teamsfx_api_1.Platform.CLI) {
            const msg = localizeUtils_1.getLocalizedString("core.deploy.aadManifestOnCLISuccessNotice");
            Context.ui.showMessage("info", msg, false);
        }
        else {
            const msg = localizeUtils_1.getLocalizedString("core.deploy.aadManifestSuccessNotice");
            Context.ui.showMessage("info", msg, false, localizeUtils_1.getLocalizedString("core.deploy.aadManifestLearnMore")).then((result) => {
                const userSelected = result.isOk() ? result.value : undefined;
                if (userSelected === localizeUtils_1.getLocalizedString("core.deploy.aadManifestLearnMore")) {
                    Context.ui.openUrl(constants_2.ViewAadAppHelpLinkV5);
                }
            });
        }
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async publishApplication(inputs, ctx) {
        inputs.stage = teamsfx_api_1.Stage.publish;
        const context = utils_2.createDriverContext(inputs);
        const res = await coordinator_1.coordinator.publish(context, inputs);
        if (res.isOk()) {
            ctx.envVars = res.value;
            return teamsfx_api_1.ok(teamsfx_api_1.Void);
        }
        else {
            // for partial success scenario, output is set in inputs object
            ctx.envVars = inputs.envVars;
            return teamsfx_api_1.err(res.error);
        }
    }
    async deployTeamsManifest(inputs, ctx) {
        inputs.manifestTemplatePath = inputs[questionNames_1.QuestionNames.TeamsAppManifestFilePath];
        const context = utils_2.createContextV3();
        const res = await appStudio_1.updateManifestV3(context, inputs);
        if (res.isOk()) {
            ctx.envVars = envUtil_1.envUtil.map2object(res.value);
        }
        return res;
    }
    async executeUserTask(func, inputs) {
        let res = teamsfx_api_1.ok(undefined);
        const context = utils_2.createDriverContext(inputs);
        if (func.method === "addSso") {
            // used in v3 only in VS
            inputs.stage = teamsfx_api_1.Stage.addFeature;
            inputs[questionNames_1.QuestionNames.Features] = constants_2.SingleSignOnOptionItem.id;
            const component = typedi_1.Container.get("sso");
            res = await component.add(context, inputs);
        }
        return res;
    }
    async addWebpart(inputs) {
        const driver = typedi_1.Container.get("spfx/add");
        const args = {
            manifestPath: inputs[constants_2.SPFxQuestionNames.ManifestPath],
            localManifestPath: inputs[constants_2.SPFxQuestionNames.LocalManifestPath],
            spfxFolder: inputs[constants_2.SPFxQuestionNames.SPFxFolder],
            webpartName: inputs[constants_2.SPFxQuestionNames.WebPartName],
            spfxPackage: create_1.SPFxVersionOptionIds.installLocally,
        };
        const Context = utils_2.createDriverContext(inputs);
        return await driver.run(args, Context);
    }
    async publishInDeveloperPortal(inputs) {
        inputs.stage = teamsfx_api_1.Stage.publishInDeveloperPortal;
        const context = utils_2.createContextV3();
        return await coordinator_1.coordinator.publishInDeveloperPortal(context, inputs);
    }
    async grantPermission(inputs) {
        inputs.stage = teamsfx_api_1.Stage.grantPermission;
        const context = utils_2.createContextV3();
        const res = await collaborator_1.grantPermission(context, inputs, globalVars_1.TOOLS.tokenProvider);
        return res;
    }
    async checkPermission(inputs) {
        inputs.stage = teamsfx_api_1.Stage.checkPermission;
        const context = utils_2.createContextV3();
        const res = await collaborator_1.checkPermission(context, inputs, globalVars_1.TOOLS.tokenProvider);
        return res;
    }
    async listCollaborator(inputs) {
        inputs.stage = teamsfx_api_1.Stage.listCollaborator;
        const context = utils_2.createContextV3();
        const res = await collaborator_1.listCollaborator(context, inputs, globalVars_1.TOOLS.tokenProvider);
        return res;
    }
    /**
     * get all dot envs
     */
    async getDotEnvs(inputs) {
        const envListRes = await envUtil_1.envUtil.listEnv(inputs.projectPath);
        if (envListRes.isErr()) {
            return teamsfx_api_1.err(envListRes.error);
        }
        const res = {};
        for (const env of envListRes.value) {
            const envRes = await envUtil_1.envUtil.readEnv(inputs.projectPath, env, false, false);
            if (envRes.isErr()) {
                return teamsfx_api_1.err(envRes.error);
            }
            res[env] = envRes.value;
        }
        return teamsfx_api_1.ok(res);
    }
    async phantomMigrationV3(inputs) {
        // If the project is invalid or upgraded, the ProjectMigratorMWV3 will not take action.
        // Check invaliad/upgraded project here before call ProjectMigratorMWV3
        const projectPath = inputs.projectPath || "";
        const version = await v3MigrationUtils_1.getProjectVersionFromPath(projectPath);
        if (version.source === versionMetadata_1.VersionSource.teamsapp) {
            return teamsfx_api_1.err(new upgrade_1.NoNeedUpgradeError());
        }
        else if (version.source === versionMetadata_1.VersionSource.projectSettings) {
            const isValid = await projectMigratorV3_1.checkActiveResourcePlugins(projectPath);
            if (!isValid) {
                return teamsfx_api_1.err(new common_1.InvalidProjectError());
            }
        }
        if (version.source === versionMetadata_1.VersionSource.unknown) {
            return teamsfx_api_1.err(new common_1.InvalidProjectError());
        }
        return await this.innerMigrationV3(inputs);
    }
    async innerMigrationV3(inputs) {
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async projectVersionCheck(inputs) {
        const projectPath = inputs.projectPath || "";
        if (projectSettingsHelper_1.isValidProjectV3(projectPath) || projectSettingsHelper_1.isValidProjectV2(projectPath)) {
            const versionInfo = await v3MigrationUtils_1.getProjectVersionFromPath(projectPath);
            if (!versionInfo.version) {
                return teamsfx_api_1.err(new common_1.InvalidProjectError());
            }
            const trackingId = await v3MigrationUtils_1.getTrackingIdFromPath(projectPath);
            const isSupport = v3MigrationUtils_1.getVersionState(versionInfo);
            // if the project is upgradeable, check whether the project is valid and invalid project should not show upgrade option.
            if (isSupport === versionMetadata_1.VersionState.upgradeable) {
                if (!(await projectMigratorV3_1.checkActiveResourcePlugins(projectPath))) {
                    return teamsfx_api_1.err(new common_1.InvalidProjectError());
                }
            }
            return teamsfx_api_1.ok({
                currentVersion: versionInfo.version,
                trackingId,
                isSupport,
                versionSource: versionMetadata_1.VersionSource[versionInfo.source],
            });
        }
        else {
            return teamsfx_api_1.err(new common_1.InvalidProjectError());
        }
    }
    async preProvisionForVS(inputs) {
        const context = utils_2.createDriverContext(inputs);
        return coordinator_1.coordinator.preProvisionForVS(context, inputs);
    }
    async preCheckYmlAndEnvForVS(inputs) {
        const context = utils_2.createDriverContext(inputs);
        const result = await coordinator_1.coordinator.preCheckYmlAndEnvForVS(context, inputs);
        return result;
    }
    async createEnv(inputs) {
        return this.createEnvCopyV3(inputs[questionNames_1.QuestionNames.NewTargetEnvName], inputs[questionNames_1.QuestionNames.SourceEnvName], inputs.projectPath);
    }
    async createEnvCopyV3(targetEnvName, sourceEnvName, projectPath) {
        let res = await pathUtils_1.pathUtils.getEnvFilePath(projectPath, sourceEnvName);
        if (res.isErr())
            return teamsfx_api_1.err(res.error);
        const sourceDotEnvFile = res.value;
        res = await pathUtils_1.pathUtils.getEnvFilePath(projectPath, targetEnvName);
        if (res.isErr())
            return teamsfx_api_1.err(res.error);
        const targetDotEnvFile = res.value;
        if (!sourceDotEnvFile || !targetDotEnvFile)
            return teamsfx_api_1.err(new yml_1.YamlFieldMissingError("environmentFolderPath"));
        if (!(await fs_extra_1.default.pathExists(sourceDotEnvFile)))
            return teamsfx_api_1.err(new common_1.FileNotFoundError("createEnvCopyV3", sourceDotEnvFile));
        const source = await fs_extra_1.default.readFile(sourceDotEnvFile);
        const writeStream = fs_extra_1.default.createWriteStream(targetDotEnvFile);
        source
            .toString()
            .split(/\r?\n/)
            .forEach((line) => {
            const reg = /^([a-zA-Z_][a-zA-Z0-9_]*=)/g;
            const match = reg.exec(line);
            if (match) {
                if (match[1].startsWith("TEAMSFX_ENV=")) {
                    writeStream.write(`TEAMSFX_ENV=${targetEnvName}${os.EOL}`);
                }
                else {
                    writeStream.write(`${match[1]}${os.EOL}`);
                }
            }
            else {
                writeStream.write(`${line.trim()}${os.EOL}`);
            }
        });
        writeStream.end();
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async buildAadManifest(inputs) {
        const manifestTemplatePath = inputs.AAD_MANIFEST_FILE
            ? inputs.AAD_MANIFEST_FILE
            : path.join(inputs.projectPath, constants_2.AadConstants.DefaultTemplateFileName);
        if (!(await fs_extra_1.default.pathExists(manifestTemplatePath))) {
            return teamsfx_api_1.err(new common_1.FileNotFoundError("buildAadManifest", manifestTemplatePath));
        }
        await fs_extra_1.default.ensureDir(path.join(inputs.projectPath, "build"));
        const manifestOutputPath = path.join(inputs.projectPath, "build", `aad.${inputs.env}.json`);
        const Context = utils_2.createDriverContext(inputs);
        await buildAadManifest_1.buildAadManifest(Context, manifestTemplatePath, manifestOutputPath);
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async validateManifest(inputs) {
        inputs.stage = teamsfx_api_1.Stage.validateApplication;
        const context = utils_2.createDriverContext(inputs);
        const teamsAppManifestFilePath = inputs === null || inputs === void 0 ? void 0 : inputs[questionNames_1.QuestionNames.TeamsAppManifestFilePath];
        const args = {
            manifestPath: teamsAppManifestFilePath,
            showMessage: (inputs === null || inputs === void 0 ? void 0 : inputs.showMessage) != undefined ? inputs.showMessage : true,
        };
        const driver = typedi_1.Container.get("teamsApp/validateManifest");
        const result = await driver.run(args, context);
        return result;
    }
    async validateAppPackage(inputs) {
        inputs.stage = teamsfx_api_1.Stage.validateApplication;
        const context = utils_2.createDriverContext(inputs);
        const teamsAppPackageFilePath = inputs === null || inputs === void 0 ? void 0 : inputs[questionNames_1.QuestionNames.TeamsAppPackageFilePath];
        const args = {
            appPackagePath: teamsAppPackageFilePath,
            showMessage: true,
        };
        const driver = typedi_1.Container.get("teamsApp/validateAppPackage");
        return await driver.run(args, context);
    }
    async createAppPackage(inputs) {
        var _a, _b, _c;
        inputs.stage = teamsfx_api_1.Stage.createAppPackage;
        const context = utils_2.createDriverContext(inputs);
        const teamsAppManifestFilePath = inputs === null || inputs === void 0 ? void 0 : inputs[questionNames_1.QuestionNames.TeamsAppManifestFilePath];
        const driver = typedi_1.Container.get("teamsApp/zipAppPackage");
        const args = {
            manifestPath: teamsAppManifestFilePath,
            outputZipPath: (_a = inputs[questionNames_1.QuestionNames.OutputZipPathParamName]) !== null && _a !== void 0 ? _a : `${inputs.projectPath}/${teamsfx_api_1.AppPackageFolderName}/${teamsfx_api_1.BuildFolderName}/appPackage.${process.env.TEAMSFX_ENV}.zip`,
            outputJsonPath: (_b = inputs[questionNames_1.QuestionNames.OutputManifestParamName]) !== null && _b !== void 0 ? _b : `${inputs.projectPath}/${teamsfx_api_1.AppPackageFolderName}/${teamsfx_api_1.BuildFolderName}/manifest.${process.env.TEAMSFX_ENV}.json`,
        };
        const result = await driver.run(args, context);
        if (context.platform === teamsfx_api_1.Platform.VSCode) {
            if (result.isOk()) {
                const isWindows = process.platform === "win32";
                let zipFileName = args.outputZipPath;
                if (!path.isAbsolute(zipFileName)) {
                    zipFileName = path.join(context.projectPath, zipFileName);
                }
                let builtSuccess = localizeUtils_1.getLocalizedString("plugins.appstudio.buildSucceedNotice.fallback", zipFileName);
                if (isWindows) {
                    const folderLink = url_1.pathToFileURL(path.dirname(zipFileName));
                    const appPackageLink = `${constants_1.VSCodeExtensionCommand.openFolder}?%5B%22${folderLink}%22%5D`;
                    builtSuccess = localizeUtils_1.getLocalizedString("plugins.appstudio.buildSucceedNotice", appPackageLink);
                }
                (_c = context.ui) === null || _c === void 0 ? void 0 : _c.showMessage("info", builtSuccess, false);
            }
        }
        return result;
    }
    async copilotPluginAddAPI(inputs) {
        // TODO: call generator to add API
        const operations = inputs[questionNames_1.QuestionNames.ApiOperation];
        const message = localizeUtils_1.getLocalizedString("core.copilot.addAPI.success", operations, inputs.projectPath);
        this.tools.ui.showMessage("info", message, false);
        return teamsfx_api_1.ok("");
    }
    async previewWithManifest(inputs) {
        inputs.stage = teamsfx_api_1.Stage.previewWithManifest;
        const hub = inputs[questionNames_1.QuestionNames.M365Host];
        const manifestFilePath = inputs[questionNames_1.QuestionNames.TeamsAppManifestFilePath];
        const manifestRes = await ManifestUtils_1.manifestUtils.getManifestV3(manifestFilePath, false);
        if (manifestRes.isErr()) {
            return teamsfx_api_1.err(manifestRes.error);
        }
        const teamsAppId = manifestRes.value.id;
        const capabilities = ManifestUtils_1.manifestUtils.getCapabilities(manifestRes.value);
        const launchHelper = new launchHelper_1.LaunchHelper(this.tools.tokenProvider.m365TokenProvider, this.tools.logProvider);
        const result = await launchHelper.getLaunchUrl(hub, teamsAppId, capabilities);
        return result;
    }
}
tslib_1.__decorate([
    hooks_1.hooks([errorHandler_1.ErrorHandlerMW, questionMW_1.QuestionMW(question_1.questions.createProject)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCoreV3Implement.prototype, "createProject", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        envMW_1.EnvLoaderMW(false),
        concurrentLocker_1.ConcurrentLockerMW,
        contextInjector_1.ContextInjectorMW,
        envMW_1.EnvWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCoreV3Implement.prototype, "provisionResources", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        envMW_1.EnvLoaderMW(false),
        concurrentLocker_1.ConcurrentLockerMW,
        contextInjector_1.ContextInjectorMW,
        envMW_1.EnvWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCoreV3Implement.prototype, "deployArtifacts", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        questionMW_1.QuestionMW(question_1.questions.deployAadManifest),
        envMW_1.EnvLoaderMW(true, true),
        concurrentLocker_1.ConcurrentLockerMW,
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCoreV3Implement.prototype, "deployAadManifest", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        envMW_1.EnvLoaderMW(false),
        concurrentLocker_1.ConcurrentLockerMW,
        contextInjector_1.ContextInjectorMW,
        envMW_1.EnvWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCoreV3Implement.prototype, "publishApplication", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        questionMW_1.QuestionMW(question_1.questions.selectTeamsAppManifest),
        envMW_1.EnvLoaderMW(true),
        concurrentLocker_1.ConcurrentLockerMW,
        contextInjector_1.ContextInjectorMW,
        envMW_1.EnvWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCoreV3Implement.prototype, "deployTeamsManifest", null);
tslib_1.__decorate([
    hooks_1.hooks([errorHandler_1.ErrorHandlerMW, projectMigratorV3_1.ProjectMigratorMWV3, envMW_1.EnvLoaderMW(false), concurrentLocker_1.ConcurrentLockerMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCoreV3Implement.prototype, "executeUserTask", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        questionMW_1.QuestionMW(question_1.questions.addWebpart),
        projectMigratorV3_1.ProjectMigratorMWV3,
        concurrentLocker_1.ConcurrentLockerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCoreV3Implement.prototype, "addWebpart", null);
tslib_1.__decorate([
    hooks_1.hooks([errorHandler_1.ErrorHandlerMW, concurrentLocker_1.ConcurrentLockerMW, contextInjector_1.ContextInjectorMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCoreV3Implement.prototype, "publishInDeveloperPortal", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        questionMW_1.QuestionMW(question_1.questions.grantPermission),
        envMW_1.EnvLoaderMW(false, true),
        concurrentLocker_1.ConcurrentLockerMW,
        envMW_1.EnvWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCoreV3Implement.prototype, "grantPermission", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        envMW_1.EnvLoaderMW(false, true),
        concurrentLocker_1.ConcurrentLockerMW,
        envMW_1.EnvWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCoreV3Implement.prototype, "checkPermission", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        questionMW_1.QuestionMW(question_1.questions.listCollaborator),
        envMW_1.EnvLoaderMW(false, true),
        concurrentLocker_1.ConcurrentLockerMW,
        envMW_1.EnvWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCoreV3Implement.prototype, "listCollaborator", null);
tslib_1.__decorate([
    hooks_1.hooks([errorHandler_1.ErrorHandlerMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCoreV3Implement.prototype, "getDotEnvs", null);
tslib_1.__decorate([
    hooks_1.hooks([errorHandler_1.ErrorHandlerMW, projectMigratorV3_1.ProjectMigratorMWV3]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCoreV3Implement.prototype, "innerMigrationV3", null);
tslib_1.__decorate([
    hooks_1.hooks([errorHandler_1.ErrorHandlerMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCoreV3Implement.prototype, "projectVersionCheck", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        envMW_1.EnvLoaderMW(false),
        concurrentLocker_1.ConcurrentLockerMW,
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCoreV3Implement.prototype, "preProvisionForVS", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        envMW_1.EnvLoaderMW(false),
        concurrentLocker_1.ConcurrentLockerMW,
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCoreV3Implement.prototype, "preCheckYmlAndEnvForVS", null);
tslib_1.__decorate([
    hooks_1.hooks([errorHandler_1.ErrorHandlerMW, questionMW_1.QuestionMW(question_1.questions.createNewEnv), concurrentLocker_1.ConcurrentLockerMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCoreV3Implement.prototype, "createEnv", null);
tslib_1.__decorate([
    hooks_1.hooks([errorHandler_1.ErrorHandlerMW, projectMigratorV3_1.ProjectMigratorMWV3, envMW_1.EnvLoaderMW(false), concurrentLocker_1.ConcurrentLockerMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCoreV3Implement.prototype, "buildAadManifest", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        questionMW_1.QuestionMW(question_1.questions.selectTeamsAppManifest),
        concurrentLocker_1.ConcurrentLockerMW,
        envMW_1.EnvLoaderMW(true),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCoreV3Implement.prototype, "validateManifest", null);
tslib_1.__decorate([
    hooks_1.hooks([errorHandler_1.ErrorHandlerMW, questionMW_1.QuestionMW(question_1.questions.selectTeamsAppPackage), concurrentLocker_1.ConcurrentLockerMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCoreV3Implement.prototype, "validateAppPackage", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        questionMW_1.QuestionMW(question_1.questions.selectTeamsAppManifest),
        envMW_1.EnvLoaderMW(true),
        concurrentLocker_1.ConcurrentLockerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCoreV3Implement.prototype, "createAppPackage", null);
tslib_1.__decorate([
    hooks_1.hooks([errorHandler_1.ErrorHandlerMW, questionMW_1.QuestionMW(question_1.questions.copilotPluginAddAPI), concurrentLocker_1.ConcurrentLockerMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCoreV3Implement.prototype, "copilotPluginAddAPI", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        questionMW_1.QuestionMW(question_1.questions.previewWithTeamsAppManifest),
        envMW_1.EnvLoaderMW(false),
        concurrentLocker_1.ConcurrentLockerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCoreV3Implement.prototype, "previewWithManifest", null);
exports.FxCoreV3Implement = FxCoreV3Implement;
//# sourceMappingURL=FxCoreImplementV3.js.map