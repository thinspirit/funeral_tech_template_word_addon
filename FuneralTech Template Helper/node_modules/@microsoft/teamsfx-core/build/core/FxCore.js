"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.FxCore = void 0;
const tslib_1 = require("tslib");
const hooks_1 = require("@feathersjs/hooks");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const path = tslib_1.__importStar(require("path"));
require("reflect-metadata");
const telemetry_1 = require("../common/telemetry");
const parser_1 = require("../component/configManager/parser");
const constants_1 = require("../component/constants");
require("../component/driver/index");
require("../component/driver/script/scriptDriver");
const envMW_1 = require("../component/middleware/envMW");
const questionMW_1 = require("../component/middleware/questionMW");
const envUtil_1 = require("../component/utils/envUtil");
const metadataUtil_1 = require("../component/utils/metadataUtil");
const pathUtils_1 = require("../component/utils/pathUtils");
const settingsUtil_1 = require("../component/utils/settingsUtil");
const create_1 = require("../question/create");
const callback_1 = require("./callback");
const crypto_1 = require("./crypto");
const environment_1 = require("./environment");
const error_1 = require("./error");
const FxCoreImplementV3_1 = require("./FxCoreImplementV3");
const globalVars_1 = require("./globalVars");
const errorHandler_1 = require("./middleware/errorHandler");
const questionNames_1 = require("../question/questionNames");
const question_1 = require("../question");
class FxCore {
    constructor(tools) {
        this.tools = tools;
        globalVars_1.setTools(tools);
        telemetry_1.TelemetryReporterInstance.telemetryReporter = tools.telemetryReporter;
        this.v3Implement = new FxCoreImplementV3_1.FxCoreV3Implement(tools);
    }
    /**
     * @todo this's a really primitive implement. Maybe could use Subscription Model to
     * refactor later.
     */
    on(event, callback) {
        return callback_1.CallbackRegistry.set(event, callback);
    }
    /**
     * lifecycle command: create new project
     */
    async createProject(inputs) {
        return this.v3Implement.dispatch(this.createProject, inputs);
    }
    /**
     * lifecycle commands: provision
     */
    async provisionResources(inputs) {
        return this.v3Implement.dispatch(this.provisionResources, inputs);
    }
    /**
     * lifecycle commands: deploy
     */
    async deployArtifacts(inputs) {
        return this.v3Implement.dispatch(this.deployArtifacts, inputs);
    }
    async localDebug(inputs) {
        inputs.env = environment_1.environmentManager.getLocalEnvName();
        return this.provisionResources(inputs);
    }
    /**
     * none lifecycle command, v3 only
     */
    async deployAadManifest(inputs) {
        return this.v3Implement.dispatch(this.deployAadManifest, inputs);
    }
    /**
     * none lifecycle command, v3 only
     */
    async addWebpart(inputs) {
        return this.v3Implement.dispatch(this.addWebpart, inputs);
    }
    /**
     * lifecycle command: publish
     */
    async publishApplication(inputs) {
        return this.v3Implement.dispatch(this.publishApplication, inputs);
    }
    /**
     * most commands will be deprecated in V3
     */
    async executeUserTask(func, inputs) {
        return await this.v3Implement.dispatchUserTask(this.executeUserTask, func, inputs);
    }
    /**
     * v3 only none lifecycle command
     */
    async buildAadManifest(inputs) {
        return this.v3Implement.dispatch(this.buildAadManifest, inputs);
    }
    /**
     * v3 only none lifecycle command
     */
    async deployTeamsManifest(inputs) {
        return this.v3Implement.dispatch(this.deployTeamsManifest, inputs);
    }
    /**
     * v3 only none lifecycle command
     */
    async validateApplication(inputs) {
        if (inputs[questionNames_1.QuestionNames.ValidateMethod] === constants_1.validateSchemaOption.id) {
            return await this.validateManifest(inputs);
        }
        else {
            return await this.validateAppPackage(inputs);
        }
    }
    /**
     * v3 only none lifecycle command
     */
    async validateManifest(inputs) {
        return this.v3Implement.dispatch(this.validateManifest, inputs);
    }
    /**
     * v3 only none lifecycle command
     */
    async validateAppPackage(inputs) {
        return this.v3Implement.dispatch(this.validateAppPackage, inputs);
    }
    /**
     * v3 only none lifecycle command
     */
    async createAppPackage(inputs) {
        return this.v3Implement.dispatch(this.createAppPackage, inputs);
    }
    /**
     * get url to preview the app, may prompt to select env, hub and Teams manifest
     * v3 only none lifecycle command
     * @param {Inputs} inputs
     * @returns the url to preview the app
     */
    async previewWithManifest(inputs) {
        return this.v3Implement.dispatch(this.previewWithManifest, inputs);
    }
    /**
     * Warning: this API only works for CLI_HELP, it has no business with interactive run for CLI!
     */
    async getQuestions(stage, inputs) {
        inputs.stage = teamsfx_api_1.Stage.getQuestions;
        if (stage === teamsfx_api_1.Stage.create) {
            return teamsfx_api_1.ok(create_1.createProjectCliHelpNode());
        }
        return teamsfx_api_1.ok(undefined);
    }
    /**
     * get all dot envs
     */
    async getDotEnvs(inputs) {
        return this.v3Implement.dispatch(this.getDotEnvs, inputs);
    }
    /**
     * given projectPath and filePath, return whether the filePath is a env file
     */
    async isEnvFile(projectPath, inputFile) {
        const inputFileName = path.basename(inputFile);
        const envName = envUtil_1.envUtil.extractEnvNameFromFileName(inputFileName);
        if (!envName)
            return teamsfx_api_1.ok(false);
        const folderRes = await pathUtils_1.pathUtils.getEnvFolderPath(projectPath);
        if (folderRes.isErr())
            return teamsfx_api_1.err(folderRes.error);
        const envFolderPath = folderRes.value;
        if (!envFolderPath)
            return teamsfx_api_1.ok(false);
        const inputFileDir = path.dirname(inputFile);
        if (path.resolve(inputFileDir) !== path.resolve(envFolderPath))
            return teamsfx_api_1.ok(false);
        return teamsfx_api_1.ok(true);
    }
    /**
     * get projectId
     */
    async getProjectId(projectPath) {
        const ymlPath = pathUtils_1.pathUtils.getYmlFilePath(projectPath, "dev");
        const maybeProjectModel = await metadataUtil_1.metadataUtil.parse(ymlPath, "dev");
        if (maybeProjectModel.isErr()) {
            return teamsfx_api_1.err(maybeProjectModel.error);
        }
        const projectModel = maybeProjectModel.value;
        return teamsfx_api_1.ok(projectModel.projectId || "");
    }
    /**
     * get Teams App Name from yml
     */
    async getTeamsAppName(projectPath) {
        var _a;
        const ymlPath = pathUtils_1.pathUtils.getYmlFilePath(projectPath, "dev");
        const maybeProjectModel = await metadataUtil_1.metadataUtil.parse(ymlPath, "dev");
        if (maybeProjectModel.isErr()) {
            return teamsfx_api_1.err(maybeProjectModel.error);
        }
        const projectModel = maybeProjectModel.value;
        if (projectModel.provision) {
            const teamsAppCreate = (_a = projectModel.provision) === null || _a === void 0 ? void 0 : _a.driverDefs.find((d) => d.uses === "teamsApp/create");
            if (teamsAppCreate) {
                const name = teamsAppCreate.with.name;
                if (name) {
                    return teamsfx_api_1.ok(name.replace("-${{TEAMSFX_ENV}}", "") || "");
                }
            }
        }
        return teamsfx_api_1.ok("");
    }
    /**
     * get project info
     */
    async getProjectInfo(projectPath, env) {
        var _a;
        const ymlPath = pathUtils_1.pathUtils.getYmlFilePath(projectPath, env);
        const maybeProjectModel = await metadataUtil_1.metadataUtil.parse(ymlPath, env);
        if (maybeProjectModel.isErr()) {
            return teamsfx_api_1.err(maybeProjectModel.error);
        }
        const projectModel = maybeProjectModel.value;
        const readEnvRes = await envUtil_1.envUtil.readEnv(projectPath, env, false, true);
        if (readEnvRes.isErr()) {
            return teamsfx_api_1.err(readEnvRes.error);
        }
        const envObject = readEnvRes.value;
        const res = {
            projectId: projectModel.projectId || "",
            teamsAppId: "",
            teamsAppName: "",
            m365TenantId: envObject.TEAMS_APP_TENANT_ID || "",
        };
        if (projectModel.provision) {
            const teamsAppCreate = projectModel.provision.driverDefs.find((d) => d.uses === "teamsApp/create");
            if (teamsAppCreate) {
                const teamsAppIdEnvName = (_a = teamsAppCreate.writeToEnvironmentFile) === null || _a === void 0 ? void 0 : _a.teamsAppId;
                if (teamsAppIdEnvName) {
                    const teamsAppId = envObject[teamsAppIdEnvName];
                    res.teamsAppId = teamsAppId;
                }
                const name = teamsAppCreate.with.name;
                if (name) {
                    res.teamsAppName = name.replace("-${{TEAMSFX_ENV}}", "") || "";
                }
            }
        }
        return teamsfx_api_1.ok(res);
    }
    async grantPermission(inputs) {
        return this.v3Implement.dispatch(this.grantPermission, inputs);
    }
    /**
     * none lifecycle command
     */
    async checkPermission(inputs) {
        return this.v3Implement.dispatch(this.checkPermission, inputs);
    }
    /**
     * none lifecycle command
     */
    async listCollaborator(inputs) {
        return this.v3Implement.dispatch(this.listCollaborator, inputs);
    }
    async getSelectedEnv(inputs) {
        return teamsfx_api_1.ok(inputs.env); //work for both v2 and v3
    }
    async createLocalCrypto(projectPath) {
        const settingsRes = await settingsUtil_1.settingsUtil.readSettings(projectPath);
        if (settingsRes.isErr()) {
            return teamsfx_api_1.err(settingsRes.error);
        }
        const projectId = settingsRes.value.trackingId;
        const cryptoProvider = new crypto_1.LocalCrypto(projectId);
        return teamsfx_api_1.ok(cryptoProvider);
    }
    /**
     * only for vs code extension
     */
    async encrypt(plaintext, inputs) {
        const res = await this.createLocalCrypto(inputs.projectPath);
        if (res.isErr()) {
            return teamsfx_api_1.err(res.error);
        }
        return res.value.encrypt(plaintext);
    }
    /**
     * only for vs code extension
     */
    async decrypt(ciphertext, inputs) {
        const res = await this.createLocalCrypto(inputs.projectPath);
        if (res.isErr()) {
            return teamsfx_api_1.err(res.error);
        }
        return res.value.decrypt(ciphertext);
    }
    async createEnv(inputs) {
        return this.v3Implement.dispatch(this.createEnv, inputs);
    }
    // a phantom migration method for V3
    async phantomMigrationV3(inputs) {
        return this.v3Implement.dispatch(this.phantomMigrationV3, inputs);
    }
    // a project version check
    async projectVersionCheck(inputs) {
        return this.v3Implement.dispatch(this.projectVersionCheck, inputs);
    }
    // apply the given yaml template to current project.
    async apply(inputs, templatePath, lifecycleName) {
        if (!inputs.projectPath) {
            return teamsfx_api_1.err(error_1.InvalidInputError("invalid projectPath", inputs));
        }
        const projectPath = inputs.projectPath;
        if (!inputs.env) {
            return teamsfx_api_1.err(error_1.InvalidInputError("invalid env", inputs));
        }
        const env = inputs.env;
        const lifecycleName_ = lifecycleName;
        const result = await envUtil_1.envUtil.readEnv(projectPath, env);
        if (result.isErr()) {
            return teamsfx_api_1.err(result.error);
        }
        const parser = new parser_1.YamlParser();
        const maybeProjectModel = await parser.parse(templatePath);
        if (maybeProjectModel.isErr()) {
            return teamsfx_api_1.err(maybeProjectModel.error);
        }
        const projectModel = maybeProjectModel.value;
        const driverContext = {
            azureAccountProvider: globalVars_1.TOOLS.tokenProvider.azureAccountProvider,
            m365TokenProvider: globalVars_1.TOOLS.tokenProvider.m365TokenProvider,
            ui: globalVars_1.TOOLS.ui,
            progressBar: undefined,
            logProvider: globalVars_1.TOOLS.logProvider,
            telemetryReporter: globalVars_1.TOOLS.telemetryReporter,
            projectPath: projectPath,
            platform: inputs.platform,
        };
        const lifecycle = projectModel[lifecycleName_];
        if (lifecycle) {
            return this.runLifecycle(lifecycle, driverContext, env);
        }
        else {
            await driverContext.logProvider.warning(`No definition found for ${lifecycleName}`);
            return teamsfx_api_1.ok(teamsfx_api_1.Void);
        }
    }
    async runLifecycle(lifecycle, driverContext, env) {
        const r = await lifecycle.execute(driverContext);
        const runResult = r.result;
        if (runResult.isOk()) {
            await driverContext.logProvider.info(`Lifecycle ${lifecycle.name} succeeded`);
            const writeResult = await envUtil_1.envUtil.writeEnv(driverContext.projectPath, env, envUtil_1.envUtil.map2object(runResult.value));
            return writeResult.map(() => teamsfx_api_1.Void);
        }
        else {
            const error = runResult.error;
            if (error.kind === "Failure") {
                await driverContext.logProvider.error(`Failed to run ${lifecycle.name} due to ${error.error.name}: ${error.error.message}`);
                return teamsfx_api_1.err(error.error);
            }
            else {
                try {
                    const failedDriver = error.reason.failedDriver;
                    if (error.reason.kind === "UnresolvedPlaceholders") {
                        const unresolved = error.reason.unresolvedPlaceHolders;
                        await driverContext.logProvider.warning(`Unresolved placeholders: ${unresolved.join(",")} for driver ${failedDriver.uses}`);
                        return teamsfx_api_1.ok(teamsfx_api_1.Void);
                    }
                    else {
                        await driverContext.logProvider.error(`Failed to run ${lifecycle.name} due to ${error.reason.error.name}: ${error.reason.error.message}. Failed driver: ${failedDriver.uses}`);
                        return teamsfx_api_1.err(error.reason.error);
                    }
                }
                finally {
                    await envUtil_1.envUtil.writeEnv(driverContext.projectPath, env, envUtil_1.envUtil.map2object(error.env));
                }
            }
        }
    }
    async preProvisionForVS(inputs) {
        return this.v3Implement.dispatch(this.preProvisionForVS, inputs);
    }
    async preCheckYmlAndEnvForVS(inputs) {
        return this.v3Implement.dispatch(this.preCheckYmlAndEnvForVS, inputs);
    }
    async publishInDeveloperPortal(inputs) {
        return this.v3Implement.dispatch(this.publishInDeveloperPortal, inputs);
    }
    async copilotPluginAddAPI(inputs) {
        return this.v3Implement.dispatch(this.copilotPluginAddAPI, inputs);
    }
}
tslib_1.__decorate([
    hooks_1.hooks([questionMW_1.QuestionMW(question_1.questions.selectTeamsAppValidationMethod)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "validateApplication", null);
tslib_1.__decorate([
    hooks_1.hooks([errorHandler_1.ErrorHandlerMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "getQuestions", null);
tslib_1.__decorate([
    hooks_1.hooks([errorHandler_1.ErrorHandlerMW, envMW_1.EnvLoaderMW(false)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "getSelectedEnv", null);
tslib_1.__decorate([
    hooks_1.hooks([errorHandler_1.ErrorHandlerMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "encrypt", null);
tslib_1.__decorate([
    hooks_1.hooks([errorHandler_1.ErrorHandlerMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "decrypt", null);
exports.FxCore = FxCore;
//# sourceMappingURL=FxCore.js.map