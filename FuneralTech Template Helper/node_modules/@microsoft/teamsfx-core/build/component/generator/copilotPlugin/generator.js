"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.CopilotPluginGenerator = void 0;
const tslib_1 = require("tslib");
/**
 * @author yuqzho@microsoft.com
 */
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const generator_1 = require("../generator");
const path_1 = tslib_1.__importDefault(require("path"));
const actionExecutionMW_1 = require("../../middleware/actionExecutionMW");
const telemetryEvents_1 = require("../spfx/utils/telemetryEvents");
const specParser_1 = require("../../../common/spec-parser/specParser");
const questionNames_1 = require("../../../question/questionNames");
const helper_1 = require("./helper");
const componentName = "copilot-plugin-existing-api";
const templateName = "copilot-plugin-existing-api";
const appPackageName = "appPackage";
const manifestFileName = "manifest.json";
const adaptiveFolderName = "adaptiveCards";
const apiSpecFolderName = "apiSpecFiles";
const apiSpecFileName = "openapi.yaml";
class CopilotPluginGenerator {
    static async generate(context, inputs, destinationPath) {
        var _a, _b;
        // download template
        const templateRes = await generator_1.Generator.generateTemplate(context, destinationPath, templateName, undefined, undefined);
        if (templateRes.isErr())
            return teamsfx_api_1.err(templateRes.error);
        const url = (_a = inputs[questionNames_1.QuestionNames.ApiSpecLocation]) !== null && _a !== void 0 ? _a : (_b = inputs.openAIPluginManifest) === null || _b === void 0 ? void 0 : _b.api.url;
        const specParser = new specParser_1.SpecParser(url);
        const manifestPath = path_1.default.join(destinationPath, appPackageName, manifestFileName);
        const filters = inputs[questionNames_1.QuestionNames.ApiOperation];
        const openapiSpecPath = path_1.default.join(destinationPath, apiSpecFolderName, apiSpecFileName);
        await specParser.generate(manifestPath, filters, openapiSpecPath, adaptiveFolderName);
        // update manifest based on openAI plugin manifest
        if (inputs.openAIPluginManifest) {
            const updateManifestRes = await helper_1.OpenAIPluginManifestHelper.updateManifest(inputs.openAIPluginManifest, path_1.default.join(destinationPath, appPackageName));
            if (updateManifestRes.isErr())
                return teamsfx_api_1.err(updateManifestRes.error);
        }
        // TODO: log warnings
        return teamsfx_api_1.ok(undefined);
    }
}
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: componentName,
            telemetryEventName: telemetryEvents_1.TelemetryEvents.Generate,
            errorSource: componentName,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, String]),
    tslib_1.__metadata("design:returntype", Promise)
], CopilotPluginGenerator, "generate", null);
exports.CopilotPluginGenerator = CopilotPluginGenerator;
//# sourceMappingURL=generator.js.map