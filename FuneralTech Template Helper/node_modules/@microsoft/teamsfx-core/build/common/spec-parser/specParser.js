// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpecParser = void 0;
const tslib_1 = require("tslib");
const util = tslib_1.__importStar(require("util"));
const swagger_parser_1 = tslib_1.__importDefault(require("@apidevtools/swagger-parser"));
const specParserError_1 = require("./specParserError");
const interfaces_1 = require("./interfaces");
const constants_1 = require("./constants");
/**
 * A class that parses an OpenAPI specification file and provides methods to validate, list, and generate artifacts.
 */
class SpecParser {
    /**
     * Creates a new instance of the SpecParser class.
     * @param path The URL or file path of the OpenAPI specification file. The OpenAPI specification file must have a version of 3.0 or higher.
     */
    constructor(path) {
        this.specPath = path;
    }
    /**
     * Validates the OpenAPI specification file and returns a validation result.
     *
     * @returns A validation result object that contains information about any errors or warnings in the specification file.
     */
    async validate() {
        const errors = [];
        const warnings = [];
        const parser = new swagger_parser_1.default();
        try {
            if (!this.spec) {
                this.spec = (await parser.validate(this.specPath));
            }
        }
        catch (e) {
            // Spec not valid
            errors.push({ type: interfaces_1.ErrorType.SpecNotValid, content: e.toString() });
            return {
                status: interfaces_1.ValidationStatus.Error,
                warnings,
                errors,
            };
        }
        // Spec version not supported
        if (!this.spec.openapi || this.spec.openapi < "3.0.0") {
            errors.push({
                type: interfaces_1.ErrorType.VersionNotSupported,
                content: constants_1.ConstantString.SpecVersionNotSupported,
            });
            return {
                status: interfaces_1.ValidationStatus.Error,
                warnings,
                errors,
            };
        }
        // Server information invalid
        if (!this.spec.servers || this.spec.servers.length === 0) {
            errors.push({
                type: interfaces_1.ErrorType.NoServerInformation,
                content: constants_1.ConstantString.NoServerInformation,
            });
        }
        else if (this.spec.servers.length > 1) {
            errors.push({
                type: interfaces_1.ErrorType.MultipleServerInformation,
                content: constants_1.ConstantString.MultipleServerInformation,
            });
        }
        // Remote reference not supported
        const refPaths = parser.$refs.paths();
        // refPaths [0] is the current spec file path
        if (refPaths.length > 1) {
            console.log("refPaths", refPaths);
            errors.push({
                type: interfaces_1.ErrorType.RemoteRefNotSupported,
                content: util.format(constants_1.ConstantString.RemoteRefNotSupported, refPaths.join(", ")),
            });
        }
        // No supported API
        const apiMap = await this.getAllSupportedApi(this.spec);
        if (Object.keys(apiMap).length === 0) {
            errors.push({
                type: interfaces_1.ErrorType.NoSupportedApi,
                content: constants_1.ConstantString.NoSupportedApi,
            });
        }
        // OperationId missing
        const apisMissingOperationId = [];
        for (const key in apiMap) {
            const pathObjectItem = apiMap[key];
            if (!pathObjectItem.operationId) {
                apisMissingOperationId.push(key);
            }
        }
        if (apisMissingOperationId.length > 0) {
            warnings.push({
                type: interfaces_1.WarningType.OperationIdMissing,
                content: util.format(constants_1.ConstantString.MissingOperationId, apisMissingOperationId.join(", ")),
            });
        }
        let status = interfaces_1.ValidationStatus.Valid;
        if (warnings.length > 0 && errors.length === 0) {
            status = interfaces_1.ValidationStatus.Warning;
        }
        else if (errors.length > 0) {
            status = interfaces_1.ValidationStatus.Error;
        }
        return {
            status,
            warnings,
            errors,
        };
    }
    /**
     * Lists all the OpenAPI operations in the specification file.
     * @returns A string array that represents the HTTP method and path of each operation, such as ['GET /pets/{petId}', 'GET /user/{userId}']
     * according to copilot plugin spec, only list get and post method without auth
     */
    async list() {
        try {
            if (!this.spec) {
                this.spec = (await swagger_parser_1.default.validate(this.specPath));
            }
            const apiMap = await this.getAllSupportedApi(this.spec);
            return Array.from(Object.keys(apiMap));
        }
        catch (err) {
            throw new specParserError_1.SpecParserError(err.toString(), interfaces_1.ErrorType.ListFailed);
        }
    }
    /**
     * Generates and update artifacts from the OpenAPI specification file. Generate Adaptive Cards, update Teams app manifest, and generate a new OpenAPI specification file.
     * @param manifestPath A file path of the Teams app manifest file to update.
     * @param filter An array of strings that represent the filters to apply when generating the artifacts. If filter is empty, it would process nothing.
     * @param specPath An optional file path of the new OpenAPI specification file to generate. If not specified or empty, no spec file will be generated.
     * @param adaptiveCardFolder An optional folder path where the Adaptive Card files will be generated. If not specified or empty, Adaptive Card files will not be generated.
     */
    async generate(manifestPath, filter, specPath, adaptiveCardFolder, signal) {
        if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
            throw new specParserError_1.SpecParserError(constants_1.ConstantString.CancelledMessage, interfaces_1.ErrorType.Cancelled);
        }
        // TODO: implementation
    }
    async getAllSupportedApi(spec) {
        var _a;
        if (this.apiMap !== undefined) {
            return this.apiMap;
        }
        const paths = spec.paths;
        const result = {};
        for (const path in paths) {
            const methods = paths[path];
            for (const method in methods) {
                // only list get and post method without auth
                if ((method === constants_1.ConstantString.GetMethod || method === constants_1.ConstantString.PostMethod) &&
                    !((_a = methods[method]) === null || _a === void 0 ? void 0 : _a.security)) {
                    result[`${method.toUpperCase()} ${path}`] = methods[method];
                }
            }
        }
        this.apiMap = result;
        return result;
    }
}
exports.SpecParser = SpecParser;
//# sourceMappingURL=specParser.js.map