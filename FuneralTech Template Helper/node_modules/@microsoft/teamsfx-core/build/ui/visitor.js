"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.traverse = exports.getSingleOption = exports.isAutoSkipSelect = void 0;
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const error_1 = require("../error");
function isAutoSkipSelect(q) {
    if (q.type === "singleSelect" || q.type === "multiSelect") {
        const select = q;
        if (select.skipSingleOption && select.staticOptions.length === 1) {
            return true;
        }
    }
    return false;
}
exports.isAutoSkipSelect = isAutoSkipSelect;
function getSingleOption(q, option) {
    if (!option)
        option = q.staticOptions;
    const optionIsString = typeof option[0] === "string";
    let returnResult;
    if (optionIsString)
        returnResult = option[0];
    else {
        if (q.returnObject === true)
            returnResult = option[0];
        else
            returnResult = option[0].id;
    }
    if (q.type === "singleSelect")
        return returnResult;
    else
        return [returnResult];
}
exports.getSingleOption = getSingleOption;
async function getCallFuncValue(inputs, raw) {
    if (raw && typeof raw === "function") {
        return await raw(inputs);
    }
    return raw;
}
/**
 * ask question when visiting the question tree
 * @param question
 * @param core
 * @param inputs
 */
const questionVisitor = async function (question, ui, inputs, step, totalSteps) {
    if (inputs[question.name] !== undefined) {
        return teamsfx_api_1.ok({ type: "skip", result: inputs[question.name] });
    }
    const title = (await getCallFuncValue(inputs, question.title));
    if (question.type === "func") {
        try {
            let res;
            if (ui.executeFunction) {
                res = await ui.executeFunction({
                    name: question.name,
                    title: title !== null && title !== void 0 ? title : "Executing operation...",
                    func: question.func,
                    inputs: inputs,
                });
            }
            else {
                res = await question.func(inputs);
            }
            if (typeof res === "object" && "isOk" in res) {
                const fxresult = res;
                if (fxresult.isOk()) {
                    return teamsfx_api_1.ok({ type: "success", result: fxresult.value });
                }
                else {
                    return teamsfx_api_1.err(fxresult.error);
                }
            }
            return teamsfx_api_1.ok({ type: "success", result: res });
        }
        catch (e) {
            return teamsfx_api_1.err(error_1.assembleError(e));
        }
    }
    else {
        let defaultValue = undefined;
        if (question.forgetLastValue !== true && question.value)
            defaultValue = question.value;
        else {
            if (question.default) {
                if (typeof question.default === "function") {
                    defaultValue = async () => {
                        return question.default(inputs);
                    };
                }
                else {
                    defaultValue = question.default;
                }
            }
        }
        const placeholder = (await getCallFuncValue(inputs, question.placeholder));
        const prompt = (await getCallFuncValue(inputs, question.prompt));
        if (question.type === "text") {
            const validationFunc = question.validation
                ? teamsfx_api_1.getValidationFunction(question.validation, inputs)
                : undefined;
            const inputQuestion = question;
            return await ui.inputText({
                name: question.name,
                title: title,
                password: inputQuestion.password,
                default: defaultValue,
                placeholder: placeholder,
                prompt: prompt,
                validation: validationFunc,
                step: step,
                totalSteps: totalSteps,
            });
        }
        else if (question.type === "singleSelect" || question.type === "multiSelect") {
            const selectQuestion = question;
            let options = undefined;
            if (selectQuestion.dynamicOptions) {
                options = async () => {
                    return selectQuestion.dynamicOptions(inputs);
                };
            }
            else {
                if (!selectQuestion.staticOptions || selectQuestion.staticOptions.length === 0) {
                    return teamsfx_api_1.err(new error_1.EmptyOptionError());
                }
                if (selectQuestion.skipSingleOption && selectQuestion.staticOptions.length === 1) {
                    const returnResult = getSingleOption(selectQuestion, selectQuestion.staticOptions);
                    return teamsfx_api_1.ok({ type: "skip", result: returnResult });
                }
                options = selectQuestion.staticOptions;
            }
            if (question.type === "singleSelect") {
                const validationFunc = question.validation
                    ? teamsfx_api_1.getValidationFunction(question.validation, inputs)
                    : undefined;
                return await ui.selectOption({
                    name: question.name,
                    title: title,
                    options: options,
                    returnObject: selectQuestion.returnObject,
                    default: defaultValue,
                    placeholder: placeholder,
                    prompt: prompt,
                    step: step,
                    totalSteps: totalSteps,
                    buttons: question.buttons,
                    validation: validationFunc,
                    skipSingleOption: selectQuestion.skipSingleOption,
                });
            }
            else {
                const mq = selectQuestion;
                const validationFunc = question.validation
                    ? teamsfx_api_1.getValidationFunction(question.validation, inputs)
                    : undefined;
                return await ui.selectOptions({
                    name: question.name,
                    title: title,
                    options: options,
                    returnObject: selectQuestion.returnObject,
                    default: defaultValue,
                    placeholder: placeholder,
                    prompt: prompt,
                    onDidChangeSelection: mq.onDidChangeSelection,
                    step: step,
                    totalSteps: totalSteps,
                    validation: validationFunc,
                    skipSingleOption: selectQuestion.skipSingleOption,
                });
            }
        }
        else if (question.type === "multiFile") {
            const validationFunc = question.validation
                ? teamsfx_api_1.getValidationFunction(question.validation, inputs)
                : undefined;
            return await ui.selectFiles({
                name: question.name,
                title: title,
                placeholder: placeholder,
                prompt: prompt,
                default: defaultValue,
                step: step,
                totalSteps: totalSteps,
                validation: validationFunc,
            });
        }
        else if (question.type === "singleFile") {
            const validationFunc = question.validation
                ? teamsfx_api_1.getValidationFunction(question.validation, inputs)
                : undefined;
            return await ui.selectFile({
                name: question.name,
                title: title,
                placeholder: placeholder,
                prompt: prompt,
                default: defaultValue,
                step: step,
                totalSteps: totalSteps,
                validation: validationFunc,
                filters: question.filters,
            });
        }
        else if (question.type === "folder") {
            const validationFunc = question.validation
                ? teamsfx_api_1.getValidationFunction(question.validation, inputs)
                : undefined;
            return await ui.selectFolder({
                name: question.name,
                title: title,
                placeholder: placeholder,
                prompt: prompt,
                default: defaultValue,
                step: step,
                totalSteps: totalSteps,
                validation: validationFunc,
            });
        }
        else if (question.type === "singleFileOrText" && !!ui.selectFileOrInput) {
            const validationFunc = question.validation
                ? teamsfx_api_1.getValidationFunction(question.validation, inputs)
                : undefined;
            const res = await ui.selectFileOrInput({
                name: question.name,
                title: title,
                placeholder: placeholder,
                prompt: prompt,
                inputOptionItem: question.inputOptionItem,
                inputBoxConfig: question.inputBoxConfig,
                filters: question.filters,
                step: step,
                totalSteps: totalSteps,
                validation: validationFunc,
            });
            return res;
        }
    }
    return teamsfx_api_1.err(new teamsfx_api_1.UserError("API", "UnsupportedNodeType", `Unsupported question node type:${JSON.stringify(question)}`, `Unsupported question node type:${JSON.stringify(question)}`));
};
async function traverse(root, inputs, ui, telemetryReporter, visitor = questionVisitor) {
    const stack = [];
    const history = [];
    stack.push(root);
    let step = 1; // manual input step
    let totalStep = 1;
    const parentMap = new Map();
    // const valueMap = new Map<QTreeNode, unknown>();
    const autoSkipSet = new Set();
    while (stack.length > 0) {
        const curr = stack.pop();
        if (!curr)
            continue;
        //visit
        if (curr.data.type !== "group") {
            const question = curr.data;
            totalStep = step + stack.length;
            let qvRes;
            try {
                qvRes = await visitor(question, ui, inputs, step, totalStep);
                sendTelemetryEvent(telemetryReporter, qvRes, question, inputs);
            }
            catch (e) {
                return teamsfx_api_1.err(error_1.assembleError(e));
            }
            if (qvRes.isErr()) {
                // Cancel or Error
                return teamsfx_api_1.err(qvRes.error);
            }
            const inputResult = qvRes.value;
            if (inputResult.type === "back") {
                stack.push(curr);
                // find the previous input that is neither group nor func nor single option select
                let found = false;
                while (history.length > 0) {
                    const last = history.pop();
                    if (!last)
                        continue;
                    if (last.children) {
                        while (stack.length > 0) {
                            const tmp = stack[stack.length - 1];
                            if (last.children.includes(tmp)) {
                                stack.pop();
                            }
                            else {
                                break;
                            }
                        }
                    }
                    stack.push(last);
                    if (last.data.type !== "group")
                        delete inputs[last.data.name];
                    const lastIsAutoSkip = autoSkipSet.has(last);
                    if (last.data.type !== "group" && last.data.type !== "func" && !lastIsAutoSkip) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    return teamsfx_api_1.err(new error_1.UserCancelError());
                }
                --step;
                continue; //ignore the following steps
            }
            else {
                //success or skip
                question.value = inputResult.result;
                inputs[question.name] = question.value;
                if (inputResult.type === "skip" || question.type === "func") {
                    if (inputResult.type === "skip")
                        autoSkipSet.add(curr);
                }
                else {
                    ++step;
                }
            }
        }
        history.push(curr);
        if (curr.children) {
            const matchChildren = [];
            const valueInMap = findValue(curr, parentMap); //curr.data.type !== "group" ? curr.data.value : undefined; //valueMap.get(curr);
            for (const child of curr.children) {
                if (!child)
                    continue;
                if (child.condition) {
                    const validRes = await teamsfx_api_1.validate(child.condition, valueInMap, inputs);
                    if (validRes !== undefined) {
                        continue;
                    }
                }
                matchChildren.push(child);
            }
            for (let i = matchChildren.length - 1; i >= 0; --i) {
                const child = matchChildren[i];
                parentMap.set(child, curr);
                stack.push(child);
            }
        }
    }
    return teamsfx_api_1.ok(teamsfx_api_1.Void);
}
exports.traverse = traverse;
function findValue(curr, parentMap) {
    if (curr.data.type !== "group") {
        // need to convert OptionItem value into id for validation
        if (curr.data.type === "singleSelect") {
            const sq = curr.data;
            if (sq.value && typeof sq.value !== "string" && sq.value.id) {
                return sq.value.id;
            }
        }
        else if (curr.data.type === "multiSelect") {
            const mq = curr.data;
            if (mq.value && typeof mq.value[0] !== "string") {
                return mq.value.map((i) => i.id);
            }
        }
        return curr.data.value;
    }
    const parent = parentMap.get(curr);
    if (parent) {
        return findValue(parent, parentMap);
    }
    return undefined;
}
function sendTelemetryEvent(telemetryReporter, qvres, question, inputs) {
    var _a;
    if (qvres.isErr()) {
        telemetryReporter === null || telemetryReporter === void 0 ? void 0 : telemetryReporter.sendTelemetryEvent(teamsfx_api_1.TelemetryEvent.askQuestion, {
            [teamsfx_api_1.TelemetryProperty.answerType]: qvres.error.name,
            [teamsfx_api_1.TelemetryProperty.question]: question.name,
            [teamsfx_api_1.TelemetryProperty.platform]: inputs.platform,
            [teamsfx_api_1.TelemetryProperty.stage]: inputs.stage ? inputs.stage : "",
        });
    }
    else {
        telemetryReporter === null || telemetryReporter === void 0 ? void 0 : telemetryReporter.sendTelemetryEvent(teamsfx_api_1.TelemetryEvent.askQuestion, {
            [teamsfx_api_1.TelemetryProperty.answerType]: qvres.value.type,
            [teamsfx_api_1.TelemetryProperty.question]: question.name,
            [teamsfx_api_1.TelemetryProperty.answer]: question.type == "singleSelect" || question.type == "multiSelect"
                ? (_a = qvres.value.result) === null || _a === void 0 ? void 0 : _a.toString()
                : "",
            [teamsfx_api_1.TelemetryProperty.platform]: inputs.platform,
            [teamsfx_api_1.TelemetryProperty.stage]: inputs.stage ? inputs.stage : "",
        });
    }
}
//# sourceMappingURL=visitor.js.map